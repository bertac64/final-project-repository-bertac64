#!/usr/bin/perl
#
#	burn-in -- Perl command for burn-in test
#
#	Copyright 2011 by GGH srl for Igea spa
#
#	Rev 2.0 del 06/06/2013
#

use Getopt::Std;
use Socket;
use Socket qw(IPPROTO_TCP TCP_NODELAY);

################################################################################

#	Inizializzazione costanti
my $FILE = "InitDebug.log";
my $HOST_NAME = "localhost";		# Host di NFCS
my $EPCORE_PORT = 6969;				# Porta del server	
my $HVC = 1200;
my $HV = 800;						# Carica HV
my $LV = 200;						# Carica LV (ma vedi opt_l)
my $BINDIR = "/opt/eps02/bin";		# Directory dei binari
my $CONFDIR = "/opt/eps02/conf";	# Directory dei file di configurazione
my $USBPORT = "usb2";				# USB port device
my $NUSBPORT = "2-1.3";				# new poc USB port device

################################################################################

#	Prototipi delle subroutine
sub sendto($);
sub sendtoA($);
sub waitfor($$);
sub log_out($);
sub log_ko($);

################################################################################

#
#	Main del programma
#

# Definisci il nome della stringa trovata
my $Found = "";

# Abilita l'autoflush
$| = 1;

# Estrae eventuali switch da linea di comando
getopts("dqla:p:h");
my $host       = $opt_a ? $opt_a : $HOST_NAME;
my $port       = $opt_p ? $opt_p : $EPCORE_PORT;

$stop = 0;
$LV = 0	unless ($opt_l);
$BINDIR = $ENV{BINDIR} if $ENV{BINDIR};			# Se definite da shell, usa
$CONFDIR = $ENV{CONFDIR} if $ENV{CONFDIR};		# quelle (debug only)

# identifica il sistema su cui stai girando
my $is_new_poc = `uname -p` =~ /Atom/;

# Controlla che gli argomenti dello script siano corretti
if ($opt_h) {
	print STDERR "\nusage: epcli [-dqh] [-a host] [-p port]\n";
	print STDERR "       -h print this help\n";
	print STDERR "       -d enable debug output\n";
	print STDERR "       -q quiet mode: dont't print commands/results\n";
	print STDERR "       -l attiva la parte LV (default: solo HV)\n";
	print STDERR "       -a specify server address\t[$HOST_NAME]\n";
	print STDERR "       -p specify server port\n";
	print STDERR "\n";
	exit 1;
}

open(LOG, '>>./InitDebug.log');
close(Log);
# Bannerino di apertura
log_out("Starting a new burn-in sequence test =========================== ");

# In prima battuta, ferma la GUI
print STDERR "* Stopping epgui\n" unless $opt_q;
system "killall", "epgui";
sleep 3;

# Gestione del CTRL C (SIGINT)
$SIG{INT} = sub { $stop = 1;};

# Poi entra nel ciclo infinito dei test
my $output_on=1;
my $nopass=0;
my $fail=0;
my $pass=0;
for ($pass = 1;$stop==0;$pass++) {
	if(!$fail){
		if($pass != 0){
			log_out("Treatment passed");
		}
	}else{
		log_out("Treatment failed");
		$nopass++;
	}
	$fail=0;
	sleep 1;

	print STDERR "* Starting pass n. $pass\n" unless $opt_q;
	log_out("<--- Starting pass n. $pass --->");
	log_out("$nopass test failed"); 

	# Ferma il server
	print STDERR "* Stopping epcore\n" unless $opt_q;
	system "killall", "epcore";
	sleep 3;
	
	# Spegni e riaccendi la porta 2
	print STDERR "* Resetting USB bus $USBPORT\n" unless $opt_q;
	log_out("<--- Resetting usb bus $USBPORT --->");

	if (!$is_new_poc) {
		system ("echo -n $USBPORT > /sys/bus/usb/drivers/usb/unbind");
	}else{
		system ("echo -n $NUSBPORT > /sys/bus/usb/drivers/usb/unbind");
	}
	sleep 1;
	if (!$is_new_poc) {
		system ("echo -n $USBPORT > /sys/bus/usb/drivers/usb/bind");
	}else{
		system ("echo -n $NUSBPORT > /sys/bus/usb/drivers/usb/bind");
	}
	sleep 1;

	# Fai partire il server
	print STDERR "* Starting epcore\n" unless $opt_q;
	system "$BINDIR/epcore -d4 -p $CONFDIR/epcore.properties &";
	sleep 2;

	
	# Richiede una connessione con il server
	print STDERR "+ Connecting to $host:$port\n" if $opt_d;
	socket(SERVER, PF_INET, SOCK_STREAM, getprotobyname("tcp")) or die "epcli: $!";
	my $host_addr = sockaddr_in($port, inet_aton($host));
	connect(SERVER, $host_addr) or log_ko("$!") and $fail=1 and next;

	# Identifica la sessione 
	my $exit_value = 0;
	my $banner     = <SERVER>;
	print STDERR "+ > $banner" if $opt_d;

	# BITE
	print STDERR "* Executing bite\n" unless $opt_q;
#	sendtoA("bite #1") or log_ko("Can't send bite #1 command") and $fail=1;
	sendtoA("bit #1 1") or log_ko("Can't send bit #1 1 command") and $fail=1;
	waitfor("\\*OK #1", 40) or log_ko("Can't do bit #1 1 command") and $fail=1 and next;
	sleep 1;
	sendtoA("bit #1 3") or log_ko("Can't send bit #1 3 command") and $fail=1;
	waitfor("\\*OK #1", 60) or log_ko("Can't do bit #1 3 command") and $fail=1 and next;
	sleep 1;
	sendtoA("bit #1 8") or log_ko("Can't bite") and $fail=1;
	waitfor("!CS blank ready", 40) or log_ko("Can't bite") and $fail=1 and next;
	log_out("Bite passed");
	sleep 1;

	# Attendi 1 secondi e poi riprendi
	print STDERR "* Pass n. $pass done\n" unless $opt_q;
}

exit 0;

#
# Manda un comando e NON attende la risposta. 
#
sub sendto($) 
{
	my $command = shift;

	print STDOUT "< $command\n" unless $opt_q;
	send(SERVER, "$command\r\n", 0) or die "epcli: $!";
}

#
# Manda un comando e attende la risposta. Torna una stringa valida se
# la risposta e` +OK, una stringa vuota se non c'e` match o per timeout.
#
sub sendtoA($) 
{
	my $command = shift;
	my $answer = "";
	my $timeout = 3;

	sendto($command);

	eval {
		local $SIG{ALRM} = sub { die "alarm clock restart\n" };

		alarm $timeout;
#		$answer = <SERVER>;
#		chomp $answer;
#		print "ricevuto $answer\n" if $opt_d;
#		if ($answer =~ /^\+OK/) {
#			print STDOUT "= $answer\n" unless $opt_q;
#		}
#		else {
#			print STDOUT "  $answer\n" unless $opt_q;
#			$answer = "";
#		}
#		alarm 0;
		while (<SERVER>) {
			chomp;
			print "ricevuto $_\n" if $opt_d;
			if ($_ =~ /^\+OK/) {
				print STDOUT "= $_\n" unless $opt_q or not $output_on;
				$answer = $_;
				alarm 0;
				last;
			}
			elsif ($_ =~ /^\!FM/) {
				print STDOUT "= $_\n" unless $opt_q or not $output_on;
				$answer = "";
				alarm $timeout;
			}
			else {
				print STDOUT "  $_\n" unless $opt_q or not $output_on;
				$answer = "";
				alarm 0;
				last;
			}
		}
	};
	if ($@ and $@ !~ /alarm clock restart/) {
		$answer = "";
		print STDOUT "- TIMEOUT\n" unless $opt_q or not $output_on;
	}

	return $answer;
}

#
# Cerca un match del pattern passato per al massimo il tempo indicato; 
# torna 1 per OK, 0 per timeout.
#
sub waitfor($$) 
{
	my $pattern = shift;
	my $timeout = shift;
	my $retval = 0;

	$Found = "";
	eval {
		local $SIG{ALRM} = sub { die "alarm clock restart\n" };

		alarm $timeout;
		while (<SERVER>) {
			chomp;
			print "ricevuto $_\n" if $opt_d;
			print "atteso $pattern\n" if $opt_d;
			if ($_ =~ $pattern) {
				print STDOUT "= $_\n" unless $opt_q or not $output_on;
				alarm 0;
				$retval = 1;
				$Found = $_;
				die;
			}
			else {
				print STDOUT "  $_\n" unless $opt_q or not $output_on;
				alarm $timeout;
			}
		}
	};

	if (!$retval) {
#		die unless $@ eq "alarm clock restart\n";
		print STDOUT "- TIMEOUT\n" unless $opt_q or not $output_on;
	}
	return $retval;
}

#
# Stampa un log
#
sub log_out($) 
{
	my $string = shift;
	my @x = localtime(time);
	my $now_string = sprintf "%d%02d%02d%02d%02d%02d",
				$x[5]+1900, $x[4]+1, $x[3], $x[2], $x[1], $x[0];

open(LOG, '>>./InitDebug.log');
	print LOG "$now_string $string\n";
close(Log);

}

#
# Stampa un log di fallimento 
#
sub log_ko($) 
{
	my $string = shift;
	my @x = localtime(time);
	my $now_string = sprintf "%d%02d%02d%02d%02d%02d",
				$x[5]+1900, $x[4]+1, $x[3], $x[2], $x[1], $x[0];

open(LOG, '>>./InitDebug.log');

	print STDERR "! $string\n";
	print LOG "$now_string $string\n";
	
	print STDERR "! NOT passed\n";
	print LOG "$now_string NOT passed\n";

close(Log);

	return 1;
}

