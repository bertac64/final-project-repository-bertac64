#!/usr/bin/perl
#
#	epcli -- Perl command to control epcore
#
#	Copyright 2009 by GGH SrL for Igea SpA
#

use Getopt::Std;
use Socket;
use Socket qw(IPPROTO_TCP TCP_NODELAY);

################################################################################

#	Inizializzazione costanti
my $HOST_NAME = "localhost";	# Host di NFCS
my $EPCORE_PORT = 6969;			# Porta del server	

################################################################################

#	Prototipi delle subroutine
sub sendto($);
sub sendtoA($);
sub waitfor($$);

################################################################################

#
#	Main del programma
#

# Abilita l'autoflush
$| = 1;

# Estrae eventuali switch da linea di comando
getopts("dqa:p:h");
my $host       = $opt_a ? $opt_a : $HOST_NAME;
my $port       = $opt_p ? $opt_p : $EPCORE_PORT;

# Controlla che gli argomenti dello script siano corretti
if ($opt_h) {
	print STDERR "\nusage: epcli [-dqh] [-a host] [-p port]\n";
	print STDERR "       -h print this help\n";
	print STDERR "       -d enable debug output\n";
	print STDERR "       -q quiet mode: dont't print commands/results\n";
	print STDERR "       -a specify server address\t[$HOST_NAME]\n";
	print STDERR "       -p specify server port\n";
	print STDERR "\n";
	exit 1;
}

# Richiede una connessione con il server
print STDERR "+ Connecting to $host:$port\n" if $opt_d;
socket(SERVER, PF_INET, SOCK_STREAM, getprotobyname("tcp")) or die "epcli: $!";
my $host_addr = sockaddr_in($port, inet_aton($host));
connect(SERVER, $host_addr) or die "epcli: $!";

# Identifica la sessione 
my $exit_value = 0;
my $banner     = <SERVER>;
print STDERR "> $banner" unless $opt_q;

#$SIG{INT} = sub { sendto("abort"); 
#				  sleep 1; 
#				  sendto("charge 0 0"); 
#				  waitfor("!CS disch ready");
#				  die };

sendtoA("abort") or die "Can't abort";
waitfor("!CS", 2);
sleep 1;
if (sendtoA("nop") !~ /ready/) {
	sendtoA("bite #1") or die "Can't bite";
	waitfor("!CS blank ready", 40) or die "Can't bite"; 
}

sleep 1;

while (1) {
	sendtoA("rfidl #1") or die "Problems with rfid";
	waitfor("!CS ready rfid", 2);
	waitfor("\\*OK|\\*KO|\\*rfidl", 10);
	waitfor("!CS rfid ready", 2); 

	sleep 1;

	sendtoA("charge 0 0") or die "Problems with charge 0 0";
	waitfor("!CS disch ready", 4);

	sleep 1;

	if ($opt_l) {
		sendtoA("charge 500 100") or die "Problems with charge 500 100";
	}
	else {
		sendtoA("charge 500 0") or die "Problems with charge 500 0";
	}
	waitfor("!CS chrgn ready", 4);

	sendtoA("arm") or die "Problems with arm";
	waitfor("!CS ready armed", 2);

	sleep 1;

	if ($opt_l) {
		sendto("pars Needle 500 100 10 0 10 \\\\");
		sendtoA("+ 8 100 0 10 1 3") or die "Problems with pars";
	}
	else {
		sendto("pars Needle 500 100 1 100 50 \\\\");
		sendtoA("+ 8 100 2 50 1 3") or die "Problems with pars";
	}
	waitfor("!CS armed wtreat", 2);

	sleep 1;

	sendto("pulse");
	waitfor("!CS trtmt done", 2);

	sleep 1;

	sendtoA("getx #1") or die "Problems with getx";
	waitfor("\\*OK",4);

	sleep 1;

	sendto("d2r") or die "problems with d2r";
	waitfor("!CS disch ready|!CS done ready", 10);

	sleep 1;
}

exit 0;

#
# Manda un comando e NON attende la risposta. 
#
sub sendto($) 
{
	my $command = shift;

	print STDOUT "< $command\n" unless $opt_q;
	send(SERVER, "$command\r\n", 0) or die "epcli: $!";
}

#
# Manda un comando e attende la risposta. Torna una stringa valida se
# la risposta e` +OK, una stringa vuota se non c'e` match o per timeout.
#
sub sendtoA($) 
{
	my $command = shift;
	my $answer = "";

	sendto($command);

	eval {
		local $SIG{ALRM} = sub { die "alarm clock restart\n" };

		alarm 3;
		$answer = <SERVER>;
		chomp $answer;
		print "ricevuto $answer\n" if $opt_d;
		if ($answer =~ /^\+OK/) {
			print STDOUT "= $answer\n" unless $opt_q;
		}
		else {
			print STDOUT "  $answer\n" unless $opt_q;
			$answer = "";
		}
		alarm 0;
	};
	if ($@ and $@ !~ /alarm clock restart/) {
		$answer = "";
		print STDOUT "- TIMEOUT\n" unless $opt_q;
	}

	return $answer;
}

#
# Cerca un match del pattern passato per al massimo il tempo indicato; 
# torna 1 per OK, 0 per timeout.
#
sub waitfor($$) 
{
	my $pattern = shift;
	my $timeout = shift;
	my $retval = 0;

	eval {
		local $SIG{ALRM} = sub { die "alarm clock restart\n" };

		alarm $timeout;
		while (<SERVER>) {
			chomp;
			print "ricevuto $_\n" if $opt_d;
			print "atteso $pattern\n" if $opt_d;
			if ($_ =~ $pattern) {
				print STDOUT "= $_\n" unless $opt_q;
				alarm 0;
				$retval = 1;
				die;
			}
			else {
				print STDOUT "  $_\n" unless $opt_q;
				alarm $timeout;
			}
		}
	};

	if (!$retval) {
		print STDOUT "- TIMEOUT\n" unless $opt_q;
	}
	return $retval;
}

