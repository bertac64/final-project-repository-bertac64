#!/usr/bin/perl
#
#	burn-in -- Perl command for burn-in test
#
#	Copyright 2011 by GGH srl for Igea spa
#
#   Rev 1.0 del 11/12/2012
#

use Getopt::Std;
use Socket;
use Socket qw(IPPROTO_TCP TCP_NODELAY);

################################################################################

#	Inizializzazione costanti
my $HOST_NAME = "localhost";		# Host di NFCS
my $EPCORE_PORT = 6969;				# Porta del server	
my $HVC = 1200;
my $HV = 800;						# Carica HV
my $LV = 200;						# Carica LV (ma vedi opt_l)
my $BINDIR = "/opt/eps02/bin";		# Directory dei binari
my $CONFDIR = "/opt/eps02/conf";	# Directory dei file di configurazione
my $USBPORT = "usb2";				# USB port device
my $NUSBPORT = "2-1.3";				# new poc USB port device

################################################################################

#	Prototipi delle subroutine
sub sendto($);
sub sendtoA($);
sub waitfor($$);
sub log_out($);
sub log_ko($);

################################################################################

#
#	Main del programma
#

# Definisci il nome della stringa trovata
my $Found = "";

# Abilita l'autoflush
$| = 1;

# Estrae eventuali switch da linea di comando
getopts("dqla:p:h");
my $host       = $opt_a ? $opt_a : $HOST_NAME;
my $port       = $opt_p ? $opt_p : $EPCORE_PORT;

$stop = 0;
$LV = 0	unless ($opt_l);
$BINDIR = $ENV{BINDIR} if $ENV{BINDIR};			# Se definite da shell, usa
$CONFDIR = $ENV{CONFDIR} if $ENV{CONFDIR};		# quelle (debug only)

# identifica il sistema su cui stai girando
my $is_new_poc = `uname -p` =~ /Arm/;

# Controlla che gli argomenti dello script siano corretti
if ($opt_h) {
	print STDERR "\nusage: epcli [-dqh] [-a host] [-p port]\n";
	print STDERR "       -h print this help\n";
	print STDERR "       -d enable debug output\n";
	print STDERR "       -q quiet mode: dont't print commands/results\n";
	print STDERR "       -l attiva la parte LV (default: solo HV)\n";
	print STDERR "       -a specify server address\t[$HOST_NAME]\n";
	print STDERR "       -p specify server port\n";
	print STDERR "\n";
	exit 1;
}

open(LOG, '>>./burn-in.log');
close(Log);
# Bannerino di apertura
log_out("Starting a new burn-in sequence test =========================== ");

# In prima battuta, ferma la GUI
print STDERR "* Stopping epgui\n" unless $opt_q;
system "killall", "epgui";
sleep 3;

# Gestione del CTRL C (SIGINT)
$SIG{INT} = sub { $stop = 1;};

# Poi entra nel ciclo infinito dei test
my $output_on=1;
my $nopass=0;
my $fail=0;
my $pass=0;
for ($pass = 1;$stop==0;$pass++) {
	if(!$fail){
		if($pass != 0){
			log_out("Treatment passed");
		}
	}else{
		log_out("Treatment failed");
		$nopass++;
	}
	$fail=0;
	sleep 1;

	print STDERR "* Starting pass n. $pass\n" unless $opt_q;
	log_out("<--- Starting pass n. $pass --->");
	log_out("$nopass test failed"); 

	# Ferma il server
	print STDERR "* Stopping epcore\n" unless $opt_q;
	system "killall", "epcore";
	sleep 3;
	
	# Spegni e riaccendi la porta 2
#	if (!$is_new_poc) {
		print STDERR "* Resetting USB bus $USBPORT\n" unless $opt_q;
		log_out("<--- Resetting usb bus $USBPORT --->");

		if (!$is_new_poc) {
			system ("echo -n $USBPORT > /sys/bus/usb/drivers/usb/unbind");
		}else{
			system ("echo -n $NUSBPORT > /sys/bus/usb/drivers/usb/unbind");
		}
		sleep 1;
		if (!$is_new_poc) {
			system ("echo -n $USBPORT > /sys/bus/usb/drivers/usb/bind");
		}else{
			system ("echo -n $NUSBPORT > /sys/bus/usb/drivers/usb/bind");
		}
		sleep 1;
#	}

	# Fai partire il server
	print STDERR "* Starting epcore\n" unless $opt_q;
	system "$BINDIR/epcore -p $CONFDIR/epcore.properties &";
	sleep 2;

	
	# Richiede una connessione con il server
	print STDERR "+ Connecting to $host:$port\n" if $opt_d;
	socket(SERVER, PF_INET, SOCK_STREAM, getprotobyname("tcp")) or die "epcli: $!";
	my $host_addr = sockaddr_in($port, inet_aton($host));
	connect(SERVER, $host_addr) or log_ko("$!") and $fail=1 and next;

	# Identifica la sessione 
	my $exit_value = 0;
	my $banner     = <SERVER>;
	print STDERR "+ > $banner" if $opt_d;

	# BITE
	print STDERR "* Executing bite\n" unless $opt_q;
#	sendtoA("bite #1") or log_ko("Can't bite") and $fail=1;
	sendtoA("bit #1 1") or log_ko("Can't send bit #1 1 command") and $fail=1;
	waitfor("\\*OK #1", 40) or log_ko("Can't do bit #1 1 command") and $fail=1 and next;
	sleep 1;
	sendtoA("bit #1 2") or log_ko("Can't send bit #1 2 command") and $fail=1;
	waitfor("\\*OK #1", 40) or log_ko("Can't do bit #1 2 command") and $fail=1 and next;
	sleep 1;
	sendtoA("bit #1 3") or log_ko("Can't send bit #1 3 command") and $fail=1;
	waitfor("\\*OK #1", 60) or log_ko("Can't do bit #1 3 command") and $fail=1 and next;
	sleep 1;
	sendtoA("bit #1 4") or log_ko("Can't send bit #1 4 command") and $fail=1;
	waitfor("\\*OK #1", 60) or log_ko("Can't do bit #1 4 command") and $fail=1 and next;
	sleep 1;
	sendtoA("bit #1 5") or log_ko("Can't send bit #1 5 command") and $fail=1;
	waitfor("\\*OK #1", 60) or log_ko("Can't do bit #1 5 command") and $fail=1 and next;
	sleep 1;
	sendtoA("bit #1 6") or log_ko("Can't send bit #1 6 command") and $fail=1;
	waitfor("\\*OK #1", 120) or log_ko("Can't do bit #1 6 command") and $fail=1 and next;
	sleep 1;
	sendtoA("bit #1 7") or log_ko("Can't send bit #1 7 command") and $fail=1;
	waitfor("\\*OK #1", 120) or log_ko("Can't do bit #1 7 command") and $fail=1 and next;
	sleep 1;
	sendtoA("bit #1 8") or log_ko("Can't bite") and $fail=1;
	waitfor("!CS blank ready", 40) or log_ko("Can't bite") and $fail=1 and next;
	log_out("Bite passed");
	sleep 1;

	# Attivazione RFID
	print STDERR "* Checking rfid\n" unless $opt_q;
#	sendtoA("rfidl #1") or log_ko("Problems with rfid") and next;
	sendtoA("rfidl #1 12345678") or log_ko("Problems with rfid") and $fail=1 and next;
	waitfor("!CS ready rfid", 2) or log_ko("Problems with rfid") and $fail=1 and next;
	waitfor("\\*OK|\\*KO|\\*rfidl", 20) or log_ko("Problems with rfid") and $fail=1 and next;
	waitfor("!CS rfid ready", 2) or log_ko("Problems with rfid") and $fail=1 and next;
	log_out("Rfid passed");
	sleep 1;
	
	# Trattamento con esagonale *******************************************
	
	# Carica
	print STDERR "* Charging\n" unless $opt_q;
	sendtoA("charge $HVC $LV") or log_ko("Problems sending charge cmd $HVC $LV") and $fail=1 and next;
	msleep(500);
	waitfor("!CS chrgn ready", 4) or log_ko("Problems with charge $HV $LV") and $fail=1 and next;
	msleep(1000);
	
	# Arm
	print STDERR "* Arming\n" unless $opt_q;
	sendtoA("arm") or log_ko("Problems with arm") and $fail=1 and next;
	waitfor("!CS ready armed", 2) or log_ko("Problems with arm") and $fail=1 and next;
	sleep 1;
	
	# Esagonale di Villejuiff
	my $N_LV = ($opt_l)? 2: 0;
	my $L_LV = ($opt_l)? 50: 0;

	print STDERR "* Sending pars (Villejuiff)\n" unless $opt_q;
	sendto("pars Hexagon $HV 100 1 $LV 10 \\\\") or log_ko("Problems with pars") and $fail=1 and next;
	sendto("+ 4 100 $N_LV $L_LV 40 41 \\\\") or log_ko("Problems with pars") and $fail=1 and next;
	sendto("+ 4 100 $N_LV $L_LV 02 06 \\\\") or log_ko("Problems with pars") and $fail=1 and next;
	sendto("+ 4 100 $N_LV $L_LV 40 48 \\\\") or log_ko("Problems with pars") and $fail=1 and next;
	sendto("+ 4 100 $N_LV $L_LV 10 30 \\\\") or log_ko("Problems with pars") and $fail=1 and next;
	sendto("+ 4 100 $N_LV $L_LV 40 42 \\\\") or log_ko("Problems with pars") and $fail=1 and next;
	sendto("+ 4 100 $N_LV $L_LV 04 0C \\\\") or log_ko("Problems with pars") and $fail=1 and next;
	sendto("+ 4 100 $N_LV $L_LV 40 50 \\\\") or log_ko("Problems with pars") and $fail=1 and next;
	sendto("+ 4 100 $N_LV $L_LV 20 21 \\\\") or log_ko("Problems with pars") and $fail=1 and next;
	sendto("+ 4 100 $N_LV $L_LV 40 44 \\\\") or log_ko("Problems with pars") and $fail=1 and next;
	sendto("+ 4 100 $N_LV $L_LV 08 18 \\\\") or log_ko("Problems with pars") and $fail=1 and next;
	sendto("+ 4 100 $N_LV $L_LV 40 60 \\\\") or log_ko("Problems with pars") and $fail=1 and next;
	sendto("+ 4 100 $N_LV $L_LV 01 03 \\\\") or log_ko("Problems with pars") and $fail=1 and next;
	sendto("+ 4 100 $N_LV $L_LV 20 60 \\\\") or log_ko("Problems with pars") and $fail=1 and next;
	sendto("+ 4 100 $N_LV $L_LV 10 18 \\\\") or log_ko("Problems with pars") and $fail=1 and next;
	sendto("+ 4 100 $N_LV $L_LV 04 44 \\\\") or log_ko("Problems with pars") and $fail=1 and next;
	sendto("+ 4 100 $N_LV $L_LV 02 03 \\\\") or log_ko("Problems with pars") and $fail=1 and next;
	sendto("+ 4 100 $N_LV $L_LV 10 50 \\\\") or log_ko("Problems with pars") and $fail=1 and next;
	sendto("+ 4 100 $N_LV $L_LV 08 0C \\\\") or log_ko("Problems with pars") and $fail=1 and next;
	sendto("+ 4 100 $N_LV $L_LV 02 42 \\\\") or log_ko("Problems with pars") and $fail=1 and next;
	sendto("+ 4 100 $N_LV $L_LV 01 21 \\\\") or log_ko("Problems with pars") and $fail=1 and next;
	sendto("+ 4 100 $N_LV $L_LV 08 48 \\\\") or log_ko("Problems with pars") and $fail=1 and next;
	sendto("+ 4 100 $N_LV $L_LV 04 06 \\\\") or log_ko("Problems with pars") and $fail=1 and next;
	sendto("+ 4 100 $N_LV $L_LV 01 41 \\\\") or log_ko("Problems with pars") and $fail=1 and next;
	sendtoA("+ 4 100 $N_LV $L_LV 20 30") or log_ko("Problems with pars") and $fail=1 and next;

	waitfor("!CS armed wtreat", 2) or log_ko("Problems with pars") and $fail=1 and next;
	sleep 1;
	
	# Pulse
	print STDERR "* Starting treatment\n" unless $opt_q;
	sendto("pulse") or log_ko("Problems with pulse") and $fail=1 and next;
	waitfor("!CS trtmt done", 2) or log_ko("Problems with pulse") and $fail=1 and next;
	sleep 1;
	
	# Get
	print STDERR "* Retriving data\n" unless $opt_q;
	$output_on = 0;
	sendtoA("get #2") or log_ko("Problems with get") and $fail=1 and next;
	waitfor("\\*get #2 Q", 10) or log_ko("Problems with get") and $fail=1 and next;
	$output_on = 1;

	# Calcola la QoT
	my @ans = split / /, $Found;
	log_ko("bad QoT: $ans[4]") if ($ans[3] != "0") and next;

	waitfor("\\*OK", 4) or log_ko("Problems with get") and last;
	sendto("d2r") or log_ko("Problems with d2r") and last;

	waitfor("!CS chrgn ready|!CS done ready", 10) or log_ko("Problems with get") and $fail=1 and next;
	sleep 1;

	# Scarica
	print STDERR "* Discharging\n" unless $opt_q;
	sendtoA("charge 0 0") or log_ko("Problems with charge 0 0") and $fail=1 and next;
	waitfor("!CS disch ready", 20) or log_ko("Problems with charge 0 0") and $fail=1 and next;
	
	# Attendi 1 secondi e poi riprendi
	print STDERR "* Pass n. $pass done\n" unless $opt_q;
}

exit 0;

#
# Manda un comando e NON attende la risposta. 
#
sub sendto($) 
{
	my $command = shift;

	print STDOUT "< $command\n" unless $opt_q;
	send(SERVER, "$command\r\n", 0) or die "epcli: $!";
}

#
# Manda un comando e attende la risposta. Torna una stringa valida se
# la risposta e` +OK, una stringa vuota se non c'e` match o per timeout.
#
sub sendtoA($) 
{
	my $command = shift;
	my $answer = "";
	my $timeout = 3;

	sendto($command);

	eval {
		local $SIG{ALRM} = sub { die "alarm clock restart\n" };

		alarm $timeout;
#		$answer = <SERVER>;
#		chomp $answer;
#		print "ricevuto $answer\n" if $opt_d;
#		if ($answer =~ /^\+OK/) {
#			print STDOUT "= $answer\n" unless $opt_q;
#		}
#		else {
#			print STDOUT "  $answer\n" unless $opt_q;
#			$answer = "";
#		}
#		alarm 0;
		while (<SERVER>) {
			chomp;
			print "ricevuto $_\n" if $opt_d;
			if ($_ =~ /^\+OK/) {
				print STDOUT "= $_\n" unless $opt_q or not $output_on;
				$answer = $_;
				alarm 0;
				last;
			}
			elsif ($_ =~ /^\!FM/) {
				print STDOUT "= $_\n" unless $opt_q or not $output_on;
				$answer = "";
				alarm $timeout;
			}
			else {
				print STDOUT "  $_\n" unless $opt_q or not $output_on;
				$answer = "";
				alarm 0;
				last;
			}
		}
	};
	if ($@ and $@ !~ /alarm clock restart/) {
		$answer = "";
		print STDOUT "- TIMEOUT\n" unless $opt_q or not $output_on;
	}

	return $answer;
}

#
# Cerca un match del pattern passato per al massimo il tempo indicato; 
# torna 1 per OK, 0 per timeout.
#
sub waitfor($$) 
{
	my $pattern = shift;
	my $timeout = shift;
	my $retval = 0;

	$Found = "";
	eval {
		local $SIG{ALRM} = sub { die "alarm clock restart\n" };

		alarm $timeout;
		while (<SERVER>) {
			chomp;
			print "ricevuto $_\n" if $opt_d;
			print "atteso $pattern\n" if $opt_d;
			if ($_ =~ $pattern) {
				print STDOUT "= $_\n" unless $opt_q or not $output_on;
				alarm 0;
				$retval = 1;
				$Found = $_;
				die;
			}
			else {
				print STDOUT "  $_\n" unless $opt_q or not $output_on;
				alarm $timeout;
			}
		}
	};

	if (!$retval) {
		print STDOUT "- TIMEOUT\n" unless $opt_q or not $output_on;
	}
	return $retval;
}

#
# Stampa un log
#
sub log_out($) 
{
	my $string = shift;
	my @x = localtime(time);
	my $now_string = sprintf "%d%02d%02d%02d%02d%02d",
				$x[5]+1900, $x[4]+1, $x[3], $x[2], $x[1], $x[0];

open(LOG, '>>./burn-in.log');
	print LOG "$now_string $string\n";
close(Log);

}

#
# Stampa un log di fallimento 
#
sub log_ko($) 
{
	my $string = shift;
	my @x = localtime(time);
	my $now_string = sprintf "%d%02d%02d%02d%02d%02d",
				$x[5]+1900, $x[4]+1, $x[3], $x[2], $x[1], $x[0];

open(LOG, '>>./burn-in.log');

	print STDERR "! $string\n";
	print LOG "$now_string $string\n";
	
	print STDERR "! NOT passed\n";
	print LOG "$now_string NOT passed\n";

close(Log);

	return 1;
}

#
# Attendi i dati per il numero di ms (minimo 100)
#
sub msleep($)
{
	my $ms = shift;
	$ms = 100 if $ms < 100;

	select(undef, undef, undef, $ms/1000);
}

